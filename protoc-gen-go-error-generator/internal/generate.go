package internal

import (
	"fmt"
	"github.com/jhump/protoreflect/desc"
	"github.com/jhump/protoreflect/desc/protoparse"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/encoding/prototext"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/descriptorpb"
	"strconv"
	"strings"
)

var (
	Version                    = "v1.0.0"
	currentFileErrorMapWrapper = MapWrapper{MapInfo: make(map[string][]ErrorInfo)}
	mergedErrorMapWrapper      = MapWrapper{MapInfo: make(map[string][]ErrorInfo)}
	errImport                  = ImportPackInfo{Alias: "errors", PackagePath: ""}
	// name Information related to Error  struct, including Error structure name, errorCode field name, errorMsg field name,
	// used to dynamically generate Error template code. those name come from descriptor file's Error Message
	errorNameInfo       = ErrorNameInfo{}
	_descriptorFilePath = ""
	_mergeError         = false
	_mergeErrorPath     = ""
)

// ExtendOption Extension field for EnumValueOptions in the description file
// for example:
// OptionName:msg
// OptionNumber:1108
type ExtendOption struct {
	OptionName   string
	OptionNumber int32
}

var descriptorFileExtendOptions []ExtendOption

// ErrorNameInfo
type ErrorNameInfo struct {
	ErrorStructName string
	CodeFieldName   string
	MsgFieldName    string
}

// GenerateFile generates a _errors.pb.go file containing errors definitions.
func GenerateFile(gen *protogen.Plugin, file *protogen.File, isLastFile bool, descriptorFilePath, mergeErrorPath *string, mergeError *bool) *protogen.GeneratedFile {
	if mergeErrorPath == nil || len(*mergeErrorPath) == 0 {
		panic("merge error path can not empty")
	}
	if descriptorFilePath == nil || len(*descriptorFilePath) == 0 {
		panic("descriptor file path can not empty")
	}
	_mergeErrorPath = *mergeErrorPath
	if len(file.Enums) == 0 {
		return nil
	}
	_descriptorFilePath = *descriptorFilePath
	if mergeError != nil {
		_mergeError = *mergeError
	}
	goPackage, _ := resolveDescriptorFile()
	errImport = ImportPackInfo{Alias: getPathLastParty(goPackage), PackagePath: goPackage}

	filename := file.GeneratedFilenamePrefix + "_errors.pb.go" // file.GeneratedFilenamePrefix such as: /multiple_file/golang/error/account/errors
	g := gen.NewGeneratedFile(filename, file.GoImportPath)
	genCommentContent(g)
	g.P("package ", file.GoPackageName)
	generateFileContent(gen, file, g, isLastFile, _mergeError)
	return g
}

// genCommentContent
func genCommentContent(g *protogen.GeneratedFile) {
	g.P("// Code generated by protoc-gen-go-error-generator. DO NOT EDIT.")
	g.P("// Version " + Version)
}

// genErrMergeMapFile Generate a file named errors_errors.pb.go containing the merged err map under the path specified by the user
func genErrMergeMapFile(gen *protogen.Plugin) *protogen.GeneratedFile {
	filename := _mergeErrorPath + "/errors_errors.pb.go"
	g := gen.NewGeneratedFile(filename, protogen.GoImportPath(_mergeErrorPath))
	genCommentContent(g)
	g.P("package ", getPathLastParty(_mergeErrorPath))
	genImports(g)
	genMergedErrorMap(g)
	return g
}

// getPathLastParty return path's last string by Separator "/"
// for example input: "multiple_file/golang/errors" output:"errors"
func getPathLastParty(path string) string {
	array := strings.Split(path, "/")
	if len(array) > 0 {
		return array[len(array)-1]
	}
	return ""
}

// generateFileContent generates the errors definitions and error Map
func generateFileContent(gen *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile, isLastFile bool, errorMapMerge bool) {
	if len(file.Enums) == 0 {
		return
	}
	g.P()
	genImports(g)
	for _, enum := range file.Enums {
		_ = genErrors(g, enum)
		if errorMapMerge {
			appendMergedErrMap(enum)
		} else {
			appendCurrentFileErrMap(enum)
		}
	}
	if errorMapMerge {
		if isLastFile {
			genErrMergeMapFile(gen)
		}
	} else {
		genCurrentProtoFileErrorMap(g)
		currentFileErrorMapWrapper = MapWrapper{MapInfo: make(map[string][]ErrorInfo)}
	}
}

// genImports generate imports
func genImports(g *protogen.GeneratedFile) {
	importWrapper := ImportWrapper{Imports: []ImportPackInfo{errImport}}
	g.P(importWrapper.execute())
}

// CheckValueHasOption check whether enum has ValueOption
func CheckValueHasOption(value *protogen.EnumValue) bool {
	if opts, ok := value.Desc.Options().(*descriptorpb.EnumValueOptions); !ok {
		return false
	} else {
		if opts == nil {
			return false
		}
	}
	return true
}

// genErrors generate error
func genErrors(g *protogen.GeneratedFile, enum *protogen.Enum) bool {
	var ew ErrorWrapper
	for _, v := range enum.Values {
		if !CheckValueHasOption(v) {
			continue
		}
		err := ErrorInfo{
			ErrorStructName: errorNameInfo.ErrorStructName,
			EnumName:        string(enum.Desc.Name()),
			EnumValue:       string(v.Desc.Name()),
			CodeFieldName:   errorNameInfo.CodeFieldName,
			Code:            int32(v.Desc.Number()),
			MsgFieldName:    errorNameInfo.MsgFieldName,
			Msg:             getOptionValue(v, descriptorFileExtendOptions[0].OptionNumber),
		}
		ew.Errors = append(ew.Errors, err)
	}
	if len(ew.Errors) == 0 {
		return true
	}
	g.P(ew.execute())
	return false
}

// Read the name and number of the extended ExtendOption from the error description file,
// and return the go_package in the description file
func resolveDescriptorFile() (string, error) {
	parser := &protoparse.Parser{}
	files, err := parser.ParseFiles(_descriptorFilePath)
	if err != nil {
		panic(fmt.Sprintf("failed to parse file. descriptorFilePath:%s err: %s", _descriptorFilePath, err))
	}
	if len(files) == 0 {
		panic(fmt.Sprintf("no parsed success file find"))
	}
	f := files[0]
	goPackage := f.GetFileOptions().GoPackage
	if goPackage == nil || len(*goPackage) == 0 {
		panic("descriptor file must definition go_package")
	}
	messages := f.GetMessageTypes()
	if len(messages) == 0 {
		panic("descriptor file must definition at least one message")
	}
	// default take the first Message use for Error
	messageName, firstIntFieldName, firstStringFieldName := resolveErrorMessage(messages[0])
	if len(firstIntFieldName) == 0 || len(firstStringFieldName) == 0 {
		panic("descriptor file message must definition at least one int and at least one string field")
	}
	errorNameInfo = ErrorNameInfo{
		ErrorStructName: uppercase(messageName),
		CodeFieldName:   uppercase(firstIntFieldName),
		MsgFieldName:    uppercase(firstStringFieldName),
	}
	for _, extension := range f.GetExtensions() {
		if extension.GetOwner().GetName() != "EnumValueOptions" {
			continue
		}
		msgName := extension.GetName()
		msgNumber := extension.GetNumber()
		descriptorFileExtendOptions = append(descriptorFileExtendOptions, ExtendOption{
			OptionName:   msgName,
			OptionNumber: msgNumber,
		})
	}
	if len(descriptorFileExtendOptions) == 0 {
		panic("the google.protobuf.EnumValueOptions extension is not defined in the description file")
	}
	return *goPackage, nil
}

// resolveErrorMessage Get the field name of the first int type and the first string type in the message
func resolveErrorMessage(message *desc.MessageDescriptor) (string, string, string) {
	messageName := message.GetName()
	firstIntFieldName := ""
	firstStringFieldName := ""
	for _, field := range message.GetFields() {
		fieldType := field.GetType()
		switch fieldType {
		case descriptorpb.FieldDescriptorProto_TYPE_INT32, descriptorpb.FieldDescriptorProto_TYPE_UINT32, descriptorpb.FieldDescriptorProto_TYPE_INT64, descriptorpb.FieldDescriptorProto_TYPE_UINT64:
			if len(firstIntFieldName) == 0 {
				firstIntFieldName = field.GetName()
			}
		case descriptorpb.FieldDescriptorProto_TYPE_STRING:
			if len(firstStringFieldName) == 0 {
				firstStringFieldName = field.GetName()
			}
		}
	}
	return messageName, firstIntFieldName, firstStringFieldName
}

// appendCurrentFileErrMap Fill error to the current proto file err map, Each proto file generates an err map
func appendCurrentFileErrMap(enum *protogen.Enum) {
	appendErrMap(enum, &currentFileErrorMapWrapper)
}

// appendCurrentFileErrMap Fill error to merged err map，All proto files are merged into one err map
func appendMergedErrMap(enum *protogen.Enum) {
	appendErrMap(enum, &mergedErrorMapWrapper)
}

// appendErrMap Take the msg from the enum value option in the proto file, assemble it into an error and fill it into the err map
func appendErrMap(enum *protogen.Enum, mapWrapper *MapWrapper) {
	defaultOptionName := descriptorFileExtendOptions[0].OptionName
	defaultOptionNumber := descriptorFileExtendOptions[0].OptionNumber
	defaultOptionNameFirstUpper := uppercase(defaultOptionName)
	for _, v := range enum.Values {
		if !CheckValueHasOption(v) {
			continue
		}
		code := int32(v.Desc.Number())
		for _, err := range mapWrapper.MapInfo[defaultOptionNameFirstUpper] {
			if code != 0 && code == err.Code {
				panic(fmt.Sprintf("repeated errCode:%d", code))
			}
		}
		err := ErrorInfo{
			ErrorStructName: errorNameInfo.ErrorStructName,
			EnumName:        string(enum.Desc.Name()),
			EnumValue:       string(v.Desc.Name()),
			CodeFieldName:   errorNameInfo.CodeFieldName,
			Code:            code,
			MsgFieldName:    errorNameInfo.MsgFieldName,
			Msg:             getOptionValue(v, defaultOptionNumber),
		}
		for _, option := range descriptorFileExtendOptions {
			// Populate the error map with the error corresponding to the first enum value option
			if uppercase(option.OptionName) == defaultOptionNameFirstUpper {
				exists := false
				for _, errCode := range mapWrapper.MapInfo[defaultOptionNameFirstUpper] {
					if errCode.Code == code {
						exists = true
						break
					}
				}
				if !exists {
					mapWrapper.MapInfo[defaultOptionNameFirstUpper] = append(mapWrapper.MapInfo[defaultOptionNameFirstUpper], err)
				}
				continue
			}
			// Populate the error map with the error corresponding to the other enum value option
			exists := false
			optionNameFirstUpper := uppercase(option.OptionName)
			for _, errCode := range mapWrapper.MapInfo[optionNameFirstUpper] {
				if errCode.Code == code {
					exists = true
					break
				}
			}
			if !exists {
				msg := getOptionValue(v, option.OptionNumber)
				// If the extended ExtendOption is not defined in the EnumValue of the current proto file,
				// take the value of the first option in the extended EnumValueOptions
				if len(msg) == 0 {
					msg = getOptionValue(v, defaultOptionNumber)
				}
				err.Msg = msg
				mapWrapper.MapInfo[optionNameFirstUpper] = append(mapWrapper.MapInfo[optionNameFirstUpper], err)
			}
		}
	}
}

// genMergedErrorMap
func genMergedErrorMap(g *protogen.GeneratedFile) {
	mergedErrorMapWrapper.ErrorStructName = errorNameInfo.ErrorStructName
	g.P(mergedErrorMapWrapper.execute())
}

// genCurrentProtoFileErrorMap
func genCurrentProtoFileErrorMap(g *protogen.GeneratedFile) {
	currentFileErrorMapWrapper.ErrorStructName = errorNameInfo.ErrorStructName
	g.P(currentFileErrorMapWrapper.execute())
}

// getOptionValue get option value
func getOptionValue(v *protogen.EnumValue, optionNumber int32) string {
	if v.Desc.Options() == nil {
		return ""
	}
	optionMap := resolveEnumValueOptions(v.Desc.Options())
	if value, ok := optionMap[optionNumber]; ok {
		return value
	}
	return ""
}

// resolveEnumValueOptions resolve EnumValueOptions to get the map of option number and value
// for example:
// EnumValueOptions formatted as:
// 1108:  "成功"
// 1109:  "success"
func resolveEnumValueOptions(options proto.Message) map[int32]string {
	msgNumberValueMap := make(map[int32]string)
	if opts, ok := options.(*descriptorpb.EnumValueOptions); !ok {
		return msgNumberValueMap
	} else {
		if opts == nil {
			return msgNumberValueMap
		}
		optionsStr := prototext.MarshalOptions{Multiline: true}.Format(opts)
		OptionArray := strings.Split(optionsStr, "\n")

		for _, item := range OptionArray {
			if len(item) > 0 {
				itemArray := strings.Split(item, "\"")
				number, _ := strconv.Atoi(strings.Split(itemArray[0], ":")[0])
				value := itemArray[1]
				msgNumberValueMap[int32(number)] = value
			}
		}
		return msgNumberValueMap
	}
}

// uppercase Convert the first character after the "_" character to uppercase
func uppercase(s string) string {
	if s == "" {
		return ""
	}
	array := strings.Split(s, "")
	for idx, char := range array {
		if idx == 0 {
			array[idx] = strings.ToUpper(char)
		}
		if char == "_" && idx+1 < len(array) {
			array[idx+1] = strings.ToUpper(array[idx+1])
		}
	}
	return strings.Join(array, "")
}
