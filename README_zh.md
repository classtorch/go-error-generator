Translations: [English](README.md) | [简体中文](README_zh.md)

# go-error-generator

go-error-generator是一个通过protobuf文件的Enum对象自动生成Error的插件，通过在扩展的EnumValueOptions中定义多个option轻松实现error的i18n

# 这个项目为什么存在？

在一个前后端分离项目中后端返回的错误信息需要根据不同的平台返回不同的err msg，例如中文平台下返回中文，英文平台下返回英文，但又不想用自动翻译插件解决（自动翻译插件有时翻译不准确），
而是想针对每个平台自定义err msg, 市面上有没有实现这一功能的包，于是go-error-generator诞生了

## 实现原理

go-error-generator通过传入的error描述文件中提取扩展的google.protobuf.EnumValueOptions中自定义的option（包含option name[平台]，option number）和自定义error的protobuf文件中的EnumValueOptions（
包含option number，option value[err msg]），两者通过option number关联，最终得到option name 和 option value的映射，即得到不同平台和err msg的映射。

如果要从protobuf中获取EnumValueOption的value的一般做法是：

```go
msg := ""
eMsg := proto.GetExtension(v.Desc.Options(),errors.E_MsgEnglish)
msg = eMsg.(string)
```

其中errors.E_MsgEnglish是通过扩展google.protobuf.EnumValueOptions文件用protoc-gen-go生成的对象，每次更改扩展option的名字或新增扩展option时都需要重新生成并引用该对象、重新编译插件，这
不是一种优雅的实现，而go-error-generator每次运行时会从error描述文件中读取最新的EnumValueOptions的扩展，不需要重新编译，这是一种更灵活的实现


error描述文件(errors.proto)：
```protobuf
syntax = "proto3";

package errors;

option go_package = "github.com/classtorch/go-error-generator-examples/internal/errors";

import "google/protobuf/descriptor.proto";

message Error {
  int32 code = 1;
  string msg = 2;
};

extend google.protobuf.EnumValueOptions {
  string msg = 1108;
  string msg_english = 1109;
}
```
自定义err code和msg的文件(account/errors.proto):
```protobuf
syntax = "proto3";

package uclass.service.account;

option go_package = "/golang/account";
import "errors/errors.proto";

enum ErrorCode {
  ACCOUNT_NOT_EXISTS = 0 [(errors.msg) = "账号不存在", (errors.msg_english) = "account not exist"];
}
```

生成的go代码：
```go
// Code generated by protoc-gen-go-error-generator. DO NOT EDIT.
// Version v1.0.0
package account

import (
	errors "github.com/classtorch/go-error-generator-examples/internal/errors"
)

var (
	ACCOUNT_NOT_EXISTS = &errors.Error{Code: 0, Msg: "账号不存在"} //账号不存在
)

var (
	Msg = map[int32]*errors.Error{
		0: &errors.Error{Code: 0, Msg: "账号不存在"},
	}

	Msg_English = map[int32]*errors.Error{
		0: &errors.Error{Code: 0, Msg: "account not exist"},
	}
)
```

其中：
* ACCOUNT_NOT_EXISTS可以直接用于业务逻辑函数作为go error返回，前提是使用error描述文件(errors.proto)生成go代码，且生成的Error结构体要实现go的error接口
* Msg和Msg_English这两个map就是中文和英文平台的error映射，error的Msg就是当前平台的错误文本


## 功能

* 根据Enum定义的errCode和msg自动生成error;
* 支持定义多个EnumValueOption，实现多语言;
* 支持error合并功能;
* 支持自定义Error结构体、errorCode和Msg的名称;

## 参数说明

* descriptor_file error描述文件路径，必填
* merge_error 生成的error是否合并为一个map，默认false
* merge_error_path 生成合并error文件路径，如果merge_error=true则必填

## 快速开始

### 前提条件

- [go](https://golang.org/dl/)
- [protoc](https://github.com/protocolbuffers/protobuf)
- [protoc-gen-go](https://github.com/protocolbuffers/protobuf-go)

### 安装

```shell
go install github.com/classtorch/go-error-generator/protoc-gen-go-error-generator
```

### 使用

```shell
protoc --go-error-generator_out=:. \
--go-error-generator_opt descriptor_file=errors/errors.proto \
--go-error-generator_opt merge_error=false \
--go-error-generator_opt merge_error_path=golang/errors \
--go_out=. -I . protobuf/**/errors.proto
```

## 相关链接

* [Examples](https://github.com/classtorch/go-error-generator-examples)

